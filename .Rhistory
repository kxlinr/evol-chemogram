conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
#Remove any drug treatments that were failed. Then, remove any sets with no indicated drug.
cleaned_dose_resp = removeFailedDrugs(raw_dose_resp) %>%
removeMissingDrugs()
#Convert raw fluorescence intensities to cell viability/survival (between 0 and 1); normalize per plate
norm_dose_resp = normalizeData(cleaned_dose_resp,
trim = T, #ensure no values are != 1 or != 0
neg_control = "NC-1",
pos_control = "B")
View(norm_dose_resp)
dr_filtered = norm_dose_resp %>%
select(DRUG_ID_lib, CONC, COSMIC_ID, normalized_intensity) %>%
mutate(drug=DRUG_ID_lib,
dose=CONC,
unit="uM",
rep=COSMIC_ID,
pct_surv=normalized_intensity) %>%
select(-c(DRUG_ID_lib, CONC, COSMIC_ID, normalized_intensity))
drug_id_key = dose_resp %>% select(DRUG_ID, DRUG_NAME)
View(cell_lines)
View(dr_filtered)
View(raw_dose_resp)
#Create a function to download the GDSC2 drug response datafrom the website.
get_dr <- function(cache) {
# check if file has already been downloaded at the provided cache -- if not, proceed with the download.
if(!file.exists(paste0(cache, "/GDSC2_fitted_dose_response.xlsx"))) {
# Download file, store in specified directory
curl::curl_download(
"ftp://ftp.sanger.ac.uk/pub/project/cancerrxgene/releases/current_release/GDSC2_public_raw_data_25Feb20.csv",
destfile = paste0(cache, "/GDSC2_fitted_dose_response.xlsx"))
} else { #If the file already exists, state that we will be using the existing file.
message("Using cached GDSC2 drug response data.")
}
#Load the data file
dr_df <- readxl::read_excel(paste0(cache, "/GDSC2_fitted_dose_response.xlsx"))
return(dr_df)
}
#Run the above function
fitted_dr <- get_dr(here("Data", "Raw Data"))
#Create a function to download the GDSC2 drug response datafrom the website.
get_dr <- function(cache) {
# check if file has already been downloaded at the provided cache -- if not, proceed with the download.
if(!file.exists(paste0(cache, "/GDSC2_fitted_dose_response.xlsx"))) {
# Download file, store in specified directory
curl::curl_download(
"https://cog.sanger.ac.uk/cancerrxgene/GDSC_release8.5/GDSC2_fitted_dose_response_27Oct23.xlsx",
destfile = paste0(cache, "/GDSC2_fitted_dose_response.xlsx"))
} else { #If the file already exists, state that we will be using the existing file.
message("Using cached GDSC2 drug response data.")
}
#Load the data file
dr_df <- readxl::read_excel(paste0(cache, "/GDSC2_fitted_dose_response.xlsx"))
return(dr_df)
}
#Run the above function
fitted_dr <- get_dr(here("Data", "Raw Data"))
drug_id_key = fitted_dr %>% select(DRUG_ID, DRUG_NAME)
View(drug_id_key)
saveRDS(drug_id_key, here("Data", "drug_id_key.rds"))
saveRDS(dr_filtered, here("Data", "prepped_drug_resp.rds"))
knitr::opts_chunk$set(echo = TRUE)
# devtools::install_github("cancerrxgene/gdscIC50", build_vignettes=FALSE) #restart R after downloading
library(here)
library(gdscIC50) #for cleaning and normalizing the raw drug response data
library(pheatmap) #for plotting survival and sig scores
library(gtools) #for generating the permutations/scoring table
library(plyr) #for match_df to get acc score from rank order
library(patchwork) #for plotting
library(tidyverse)
conflicted::conflict_prefer("here", "here")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("mutate", "dplyr")
conflicted::conflict_prefer("select", "dplyr")
cell_lines = readRDS(here("Data", "cleaned_cell_line_meta.rds"))
exprs_norm = readRDS(here("Data", "normalized_exprs.rds"))
drug_id_key = readRDS(here("Data", "drug_id_key.rds"))
dr_filtered = readRDS(here("Data", "prepped_drug_resp.rds"))
sig_files = list.files(here("Data", "Signatures"))
sigs = lapply(sig_files, function(x) readRDS(here("Input Data", "Signatures", "Validation Sigs", x)))
names(sigs) = gsub("\\_.*", "", sig_files) #cut off everything after the first underscore
sigs = lapply(sig_files, function(x) readRDS(here("Data", "Signatures", x)))
names(sigs) = gsub("\\_.*", "", sig_files) #cut off everything after the first underscore
## we also need the full drug names to match with the correct drug response data. I'll be entering those manually in the same order as the list shows
#make sure theyre spelled right! can check the `dose_resp` table for spelling
names(sigs)
View(drug_id_key)
sig_drugs = c("Cisplatin", "Cytarabine", "5-Fluorouracil", "Gemcitabine", "Irinotecan",
"Luminespib", "Paclitaxel", "Topotecan", "Vinblastine", "Vorinostat")
rm(sig_files)
sigs = sigs[c(1,3,4)]
sig_drugs=sig_drugs[c(1,3,4)]
#create a key to match cell lines to their subtypes
subtype_key = cell_lines %>% select(`COSMIC identifier`, Subtype_Label)
subtypes = unique(subtype_key$Subtype_Label)
colnames(subtype_key) = c("cell_line", "subtype")
class(subtype_key$cell_line) = "character"
View(subtype_key)
knitr::opts_chunk$set(echo = TRUE)
saveRDS(subtype_key, here("Data", "subtype_key.rds"))
raw_dose_resp = read_csv(here("Data", "Raw Data", "gdsc2_raw_drug_response.csv"))
#Remove any drug treatments that were failed. Then, remove any sets with no indicated drug.
cleaned_dose_resp = removeFailedDrugs(raw_dose_resp) %>%
removeMissingDrugs()
#Convert raw fluorescence intensities to cell viability/survival (between 0 and 1); normalize per plate
norm_dose_resp = normalizeData(cleaned_dose_resp,
trim = T, #ensure no values are != 1 or != 0
neg_control = "NC-1",
pos_control = "B")
saveRDS(norm_dose_resp, here("Data", "prepped_drug_resp.rds"))
prep_dose_resp <- setConcsForNlme(norm_dose_resp)
nlme_data <- prepNlmeData(prep_dose_resp, "COSMIC_ID")
rm(norm_dose_resp, prep_dose_resp)
drug_ids = unique(drug_id_key %>% filter(DRUG_NAME %in% sig_drugs))
nlme_filtered = nlme_data %>% filter(DRUG_ID_lib %in% drug_ids$DRUG_ID)
fit_nlme = function(data, drug, drug_abbrev){
#filter to only include the data for one drug
drug_id = drug_ids$DRUG_ID[which(drug_ids$DRUG_NAME==drug)]
data_filt = data %>%
filter(DRUG_ID_lib==drug_id)
#fit the model
model = fitModelNlmeData(data_filt, isLargeData = F)
stats = calcNlmeStats(model, data_filt) %>%
mutate(cell_line=as.character(CL))
stats = left_join(stats, subtype_key, by="cell_line") #add subtype labels per cl
#find median ic50s
subtype_doses = data.frame(matrix(ncol=5, nrow=length(subtypes)))
for(i in 1:length(subtypes)){
temp = (stats %>% #isolate all CLs and IC50s for one subtype
filter(subtype==subtypes[i]) %>%
select(IC50, cell_line))
subtype_doses$std_dose[i] = median(temp$IC50) #calc the standard dose we will use
subtype_doses$subtype[i] = subtypes[i] #label subtype
subtype_doses$sd[i] = sd(temp$IC50) #record the std dev of the ic50s
subtype_doses$range_dif[i] = (range(temp$IC50)[2]) - (range(temp$IC50)[1]) #record range of ic50s
subtype_doses$n[i] = length(unique(temp$cell_line)) #how many cell lines
rm(temp)
}
subtype_doses = subtype_doses[,-c(1:5)] #rm the empty cols
stats = left_join(stats, subtype_doses, by="subtype") #add the std doses to stats
stats = unique(stats) #rm all the duplicates
stats = stats %>%
mutate(CL = cell_line, #change this name back
dose = std_dose) #rename this to x
#measure obs surv @ std dose per CL
#define functions to let us predict surv at any dose, copied from source code
logist3 <- stats::selfStart( ~ 1/(1 + exp(-(x - xmid)/scal)),
initial = function(mCall, LHS, data){
xy <- stats::sortedXyData(mCall[["x"]], LHS, data)
if(nrow(xy) < 3) {
stop("Too few distinct input values to fit a logistic")
}
xmid <- stats::NLSstClosestX(xy, 0.5 )
scal <- stats::NLSstClosestX(xy, 0.75 ) - xmid
value <- c(xmid, scal)
names(value) <- mCall[c("xmid", "scal")]
value
},
parameters = c("xmid", "scal"))
getXfromConc <- function(xc, maxc) {
x <- (log(xc / maxc)/log(2))+ 9
return(x)
}
l3_model2 <- function(lx, maxc, xmid, scal){
x <- getXfromConc(exp(lx), maxc)
#     yhat <- 1/(1 + exp(1) ^ ((x - xmid) / scal))
yhat <- 1 - logist3(x, xmid, scal)
return(yhat)
}
#calculate surv at standard doses
stats = stats %>%
mutate(surv = l3_model2(lx=dose,
xmid=xmid,
scal=scal,
maxc=maxc))
#clean up duplicates/multiple measurements by taking mean
all_cl = unique(stats$cell_line)
for(i in 1:length(all_cl)){
if(nrow(stats %>% filter(cell_line == all_cl[i])) > 1){
stats$surv[which(stats$cell_line==all_cl[i])] = c(mean(stats$surv[which(stats$cell_line==all_cl[i])]),
mean(stats$surv[which(stats$cell_line==all_cl[i])]))
}
}
#plot auc dist
ggplot(stats, aes(x=auc)) +
geom_histogram(bins=32) +
labs(title = paste0("AUC Distribution for ", drug))
ggsave(here("Plots", "DRC",
paste0(drug_abbrev, "_auc_dist.png")),
width=8, height=8)
#plot ic50 dist + standard doses
ggplot(stats, aes(x=IC50)) +
geom_histogram(bins=32) +
# geom_vline(xintercept=subtype_doses$std_dose[1:nrow(subtype_doses)]) +
geom_vline(xintercept=stats$dose, alpha=0.7) +
scale_x_continuous(trans="log10") +
labs(title = paste0("IC50 Distribution for ", drug))
ggsave(here("Plots", "DRC",
paste0(drug_abbrev, "_ic50_dist.png")),
width=8, height=8)
stats$drug_abbrev = drug_abbrev #add in the drug abbreviation for the whole df
stats = stats %>% #clean up the data to send back
select(subtype, cell_line, drug_abbrev, surv)
stats = unique(stats)
return(stats)
}
nlme_fits = list()
#each drug only takes 10-20 seconds
for(i in 1:length(sigs)){
print(paste(sig_drugs[i], " -- ", Sys.time()))
nlme_fits[[i]] = fit_nlme(data=nlme_filtered,
drug=sig_drugs[i],
drug_abbrev=names(sigs)[i])
names(nlme_fits)[i] = names(sigs)[i]
}
rm(raw_dose_resp)
saveRDS(fit_results,
here("Results",
paste0(length(sigs), "sig_nlme_fitted_data.rds")))
fit_results = do.call(rbind, nlme_fits)
rm(nlme_fits)
saveRDS(fit_results,
here("Results",
paste0(length(sigs), "sig_nlme_fitted_data.rds")))
cl_order = subtype_key[order(subtype_key$subtype), "cell_line"] #order both heatmaps by alph. subtype
plot_htmp = pivot_wider(fit_results, values_from="surv",
names_from="drug_abbrev")
plot_htmp = na.omit(left_join(cl_order,plot_htmp,by="cell_line"))
rownames(plot_htmp) = plot_htmp$cell_line
plot_htmp = plot_htmp %>%
select(-subtype, -cell_line)
pal = colorRampPalette(c("#023e8a","#0096c7", "#48cae4", "#edede9", "#f77f00", "#d62828", "#6f1d1b"))
pheatmap::pheatmap(na.omit(plot_htmp)%>%
select(order(colnames(plot_htmp))), #data to use
cluster_cols=FALSE, cluster_rows=FALSE, #specify if rows/cols should be clustered
angle_col=0, show_rownames = FALSE,
color = pal(100),
main="Survival at Standard Dose Across All Cell Lines", #title
legend_labels = "Survival\n", #Where to save the file
filename=here("Plots", "Data Prep",
paste0(length(sig_drugs), "sig_surv_CL.png"))) #Where to save the file
#F(X) to subset genes within each drug sensitivity signature, then derive the sensitivity score per cell line
sig_score = function(sig_genes, exprs_norm, drug_abbrev){
exprs_norm2 = exprs_norm %>%
dplyr::select(COSMIC_ID, all_of(sig_genes))
#Find signature score for each cell line
sig_exprs = exprs_norm2[,-1] %>%
mutate(score = apply(.,1,median), cosmic_id = exprs_norm$COSMIC_ID)
#clean up result
score = sig_exprs %>% dplyr::select(cosmic_id, score)
rownames(score) = sig_exprs$cosmic_id
colnames(score) = c("cell_line", "score")
score$drug_abbrev = drug_abbrev
return(score)
}
# #Run the above function for each sig
scores = list()
for(i in 1:length(sigs)){
scores[[i]] = sig_score(sig_genes=sigs[[i]],
exprs_norm=exprs_norm,
drug_abbrev=names(sigs)[i])
names(scores)[i] = names(sigs)[i]
}
#Label cancer type of each cell line
for(i in 1:length(scores)){
#label subtypes
scores[[i]] = merge(scores[[i]], subtype_key, all=TRUE)
#replace NAs with "unclassified"
scores[[i]]$subtype = scores[[i]]$subtype %>%
replace_na('UNCLASSIFIED') #replace any more cancer subtype NAs w/ unclassif.
}
scores_df = do.call(rbind, scores)
scores_df_wide = pivot_wider(scores_df,
id_cols = c(cell_line, subtype),
names_from = drug_abbrev,
values_from = score,
values_fn = mean #for duplicate scores on the same cl+drug, use the mean
)
scores = scores_df_wide
rm(scores_df, scores_df_wide)
scores = scores %>% select(-`NA`)
plot_score_ht = left_join(cl_order,scores,by="cell_line") %>%
select(-cell_line, -subtype)
pal = colorRampPalette(c("darkred", "#bb3e03", "#e9d8a6", "#94d2bd", "#0a9396", "#005f73"))
pheatmap::pheatmap(na.omit(plot_score_ht), #data to use
cluster_cols=FALSE, cluster_rows=FALSE, #specify if rows/cols should be clustered
angle_col=0, show_rownames = FALSE,
color = pal(100),
main="Signature Scores Across All Cell Lines", #title
legend_labels = "Sig Score",
filename=here("Plots", "Data Prep",
paste0(length(sig_drugs), "sig_scores_CL.png"))) #Where to save the file
#Save
saveRDS(scores, here("Results",
paste0(length(sigs), "sig_scores.rds")))
#Reload
scores=readRDS(here("Results",
paste0(length(sigs), "sig_scores.rds")))
scores = na.omit(scores)
scores_long = pivot_longer(scores,
cols = c(names(sigs)),
names_to = "drug_abbrev",
values_to = "score")
n = length(sigs)
score_table = permutations(n, n, seq(n))
acc_scores=as.data.frame(score_table)
rm(plot_htmp)
cl_order = subtype_key[order(subtype_key$subtype), "cell_line"] #order both heatmaps by alph. subtype
plot_surv_ht = pivot_wider(fit_results, values_from="surv",
names_from="drug_abbrev")
plot_surv_ht = na.omit(left_join(cl_order,plot_surv_ht,by="cell_line"))
rownames(plot_surv_ht) = plot_surv_ht$cell_line
plot_surv_ht = plot_surv_ht %>%
select(-subtype, -cell_line)
pal = colorRampPalette(c("#023e8a","#0096c7", "#48cae4", "#edede9", "#f77f00", "#d62828", "#6f1d1b"))
pheatmap::pheatmap(na.omit(plot_surv_ht)%>%
select(order(colnames(plot_surv_ht))), #data to use
cluster_cols=FALSE, cluster_rows=FALSE, #specify if rows/cols should be clustered
angle_col=0, show_rownames = FALSE,
color = pal(100),
main="Survival at Standard Dose Across All Cell Lines", #title
legend_labels = "Survival\n", #Where to save the file
filename=here("Plots", "Data Prep",
paste0(length(sig_drugs), "sig_surv_CL.png"))) #Where to save the file
rm(plot_surv_ht)
rm(plot_score_ht)
n = length(sigs)
score_table = permutations(n, n, seq(n))
acc_scores=as.data.frame(score_table)
#Add a column for the associated accuracy scores
m = nrow(acc_scores)
acc_scores = acc_scores %>%
mutate(row=row_number()) %>%
mutate(score = (m-row)/(m-1))
saveRDS(acc_scores, here("Results", paste0(n,"sig_score_table.rds")))
find_score = function(data, cl){
subset = data %>% filter(cell_line==cl) #filter to just one cl at a time
subset = subset[order(subset$surv, decreasing = FALSE),] #put drugs in order from most response to least response
if(nrow(subset)==length(sigs)){
subset$true_rank = (seq(1, length(sigs))) #label the observed sensitivity rank
subset = subset[order(subset$score, decreasing = TRUE),] #put drugs in order from most response to least response
score = match_df(acc_scores, as.data.frame(t(subset$true_rank))) #find which score goes with the prediction ranking
score=as.numeric(score$score)
} else { #there may be cell lines without data for all 10 drugs, so those need to be filtered out here
print("Missing drug")
score=NA
}
return(score)
}
all_cl = unique(fit_results$cell_line)
unscored_ranks = left_join(fit_results, scores_long,
by=c("cell_line", "subtype", "drug_abbrev"))
scored_ranks = data.frame(cell_line = all_cl, subtype = NA, accuracy = 0)
for(i in 1:length(all_cl)){
print(paste(i, "out of", length(all_cl), "--", ((i/length(all_cl))*100), "%"))
scored_ranks$cell_line[i] = all_cl[i]
scored_ranks$subtype[i] = as.character(unique(unscored_ranks %>%
filter(cell_line==all_cl[i]) %>%
select(subtype)))
value = find_score(unscored_ranks, all_cl[i])
print(value)
scored_ranks$accuracy[i] = value
}
saveRDS(scored_ranks, here("Results", paste0(length(sigs),"sig_accuracy_scores.rds")))
#all the values with NA had missing drug response data and should be excluded
nrow(scored_ranks)
scored_ranks_full = na.omit(scored_ranks) #986 to 763 for 3 sigs
nrow(scored_ranks_full)
#create a new df with one row per subtype, and columns = subtype, proportion_correct
subtype = unique(scored_ranks_full$subtype)
subtype_scores = data.frame(subtype=subtype, accuracy=0, n = 0)
for (i in 1:length(subtype)){
#Subset data per subtype
subset = scored_ranks_full[which(scored_ranks_full$subtype == subtype[i]),]
#Store subtype name
subtype_scores$subtype[i] = subtype[i]
#calc and store % of cell line survivals correctly predicted
subtype_scores$accuracy[i] = round((sum(subset$accuracy)/nrow(subset)), digits=3)
#Indicate number of cell lines in subtype (n)
subtype_scores$n[i] = nrow(subset)
}
#order the rows by highest to lowest correct
subtype_scores = subtype_scores[order(subtype_scores$accuracy),]
#To maintain this order when we plot later, factorize the column
subtype_scores$subtype <- factor(subtype_scores$subtype,
ordered = TRUE,
levels = subtype_scores$subtype)
#remove unclassified cell lines
scored_ranks_full = scored_ranks_full %>% filter(subtype != "UNCLASSIFIED")
#Set order to = subtype_scores
cancer_order = (as.character(subtype_scores$subtype))[-c(which(as.character(subtype_scores$subtype)=="UNCLASSIFIED"))]
scored_ranks_full$subtype <- factor(scored_ranks_full$subtype,
ordered = TRUE,
levels = c(cancer_order))
scored_ranks_full = scored_ranks_full[order(scored_ranks_full$subtype),]
#remove unclassified from subtype score averages
subtype_scores$subtype <- factor(subtype_scores$subtype,
ordered = TRUE,
levels = c(cancer_order))
subtype_scores = subtype_scores[order(subtype_scores$subtype),]
#save
saveRDS(scored_ranks_full, here("Results", paste0(length(sigs),"sig_accuracy_scores_cleaned.rds")))
# beeswarm boxplot
p1 = ggplot(scored_ranks_full, aes(x = subtype, y=accuracy)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
# geom_label(data=subtype_scores, aes(x = subtype, y = 0, label = n), size=7) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sigs), "-sig Chemogram"),
subtitle = paste0(nrow(scored_ranks_full)," GDSC Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
p1
# beeswarm boxplot
p1 = ggplot(scored_ranks_full, aes(x = subtype, y=accuracy)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
# geom_label(data=subtype_scores, aes(x = subtype, y = 0, label = n), size=7) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sigs), "-sig Chemogram"),
subtitle = paste0(nrow(scored_ranks_full)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
p1
ggsave(plot=p1,
filename=here("Plots", "Sig-score Ranked Survivals",
paste0(length(sigs), "sig_accuracy_boxplots.png")),
width = 15, height = 9) #save plot
epi = c("HNSC", "ESCA", "BRCA",
"COREAD", "LIHC", #"ACC", #leave this out bc it only has one cell line
"STAD", "KIRC", "LUAD",
"LUSC","MESO",
"PAAD", "THCA", "BLCA",
"CESC", "UCEC", "OV", "PRAD")
scored_ranks_epi = scored_ranks_full %>%
filter(subtype %in% epi)
p2 = ggplot(scored_ranks_epi, aes(x = subtype, y=accuracy)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
# geom_label(data=subtype_scores, aes(x = subtype, y = 0, label = n), size=7) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sigs), "-sig Chemogram"),
subtitle = paste0(nrow(scored_ranks_epi)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
p2
ggsave(plot=p1,
filename=here("Plots",
paste0(length(sigs), "sig_accuracy_boxplots.png")),
width = 15, height = 9) #save plot
ggsave(plot=p2,
filename=here("Plots", "Epithelial Cancers",
paste0(length(sigs), "sig_accuracy_boxplots_epi.png")),
width = 15, height = 9) #save plot
knitr::opts_chunk$set(echo = TRUE)
# devtools::install_github("cancerrxgene/gdscIC50", build_vignettes=FALSE) #restart R after downloading
library(here)
library(gdscIC50) #for cleaning and normalizing the raw drug response data
library(pheatmap) #for plotting survival and sig scores
library(gtools) #for generating the permutations/scoring table
library(plyr) #for match_df to get acc score from rank order
library(patchwork) #for plotting
library(tidyverse)
conflicted::conflict_prefer("here", "here")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("mutate", "dplyr")
conflicted::conflict_prefer("select", "dplyr")
cell_lines = readRDS(here("Data", "cleaned_cell_line_meta.rds"))
subtype_key = readRDS(here("Data", "subtype_key.rds"))
exprs_norm = readRDS(here("Data", "normalized_exprs.rds"))
drug_id_key = readRDS(here("Data", "drug_id_key.rds"))
norm_dose_resp = readRDS(here("Data", "prepped_drug_resp.rds"))
cell_lines = readRDS(here("Data", "cleaned_cell_line_meta.rds"))
subtype_key = readRDS(here("Data", "subtype_key.rds"))
exprs_norm = readRDS(here("Data", "normalized_exprs.rds"))
drug_id_key = readRDS(here("Data", "drug_id_key.rds"))
norm_dose_resp = readRDS(here("Data", "prepped_drug_resp.rds"))
sig_files = list.files(here("Data", "Signatures"))
sigs = lapply(sig_files, function(x) readRDS(here("Data", "Signatures", x)))
names(sigs) = gsub("\\_.*", "", sig_files) #cut off everything after the first underscore
## we also need the full drug names to match with the correct drug response data. those need to be manually entered in the *same order* as the list shows
#make sure theyre spelled right! can check the `drug_id_key` table for spelling
names(sigs) #print this to make sure the order is correct
sig_drugs = c("Cisplatin", "Cytarabine", "5-Fluorouracil", "Gemcitabine", "Irinotecan",
"Luminespib", "Paclitaxel", "Topotecan", "Vinblastine", "Vorinostat")
rm(sig_files)
sigs = sigs[c(1,3,4)]
sig_drugs=sig_drugs[c(1,3,4)]
