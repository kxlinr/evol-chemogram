pcr=pcr,
removeLowVaringGenesFrom=removeLowVaringGenesFrom,
report_pc=report_pc,
cc=cc,
percent=percent,
rsq=rsq)
op_results = read.csv2(here("Scripts", "calcPhenotype_Output", "DrugPredictions.csv"))
View(op_results)
op_r2 = read.delim(here("Scripts", "calcPhenotype_Output", "R^2.txt"),
sep="\t")
View(op_r2)
op_r2 = read.delim(here("Scripts", "calcPhenotype_Output", "R^2.txt"),
sep="\n")
op_results = readr::read_csv(here("Scripts", "calcPhenotype_Output", "DrugPredictions.csv"))
op_results = read_csv("Scripts/calcPhenotype_Output/DrugPredictions.csv")
op_results = readr::read_csv("Scripts/calcPhenotype_Output/DrugPredictions.csv")
op_results = readr::read_csv("calcPhenotype_Output/DrugPredictions.csv")
library(here)
wd()
getwd()
op_results = readr::read_csv(here("Scripts", "calcPhenotype_Output", "DrugPredictions.csv"))
library(readr)
DrugPredictions <- read_csv("Scripts/calcPhenotype_Output/DrugPredictions.csv")
# Run the method
op_results = calcPhenotype(trainingExprData=trainingExprData,
trainingPtype=trainingPtype,
testExprData=testExprData,
batchCorrect=batchCorrect,
powerTransformPhenotype=powerTransformPhenotype,
removeLowVaryingGenes=removeLowVaryingGenes,
minNumSamples=minNumSamples,
selection=selection,
printOutput=printOutput,
pcr=pcr,
removeLowVaringGenesFrom=removeLowVaringGenesFrom,
report_pc=report_pc,
cc=cc,
percent=percent,
rsq=rsq,
folder=F)
#the R-squareds for each drug are kinda all over, which is fine.
#it would be a problem if they were all 1, meaning that all
#the models were overfit bc the training and testing data were the same.
rm(op_r2)
#the R-squareds for each drug are kinda all over, which is fine.
#it would be a problem if they were all 1, meaning that all
#the models were overfit bc the training and testing data were the same.
rm(testExprData, trainingExprData, trainingPtype)
rm(batchCorrect,cc, drug_prefixes,keep_cols, minNumSamples, pcr,percent,powerTransformPhenotype,printOutput,removeLowVaringGenesFrom,removeLowVaryingGenes,report_pc,rsq,selection)
cell_lines = readRDS(here("Data", "cleaned_cell_line_meta.rds"))
subtype_key = readRDS(here("Data", "subtype_key.rds"))
View(cell_lines)
View(subtype_key)
#the output is predicted IC50s, which aren't comparable between drugs,
#so we'll convert them to z-scores across all samples, per drug.
op_norm = scale(op_results, center=TRUE)
View(op_norm)
acc_scores = readRDS(here("Results", paste0(length(sigs),"sig_score_table.rds")))
acc_scores = readRDS(here("Results", paste0(length(sig_drugs),"sig_score_table.rds")))
View(acc_scores)
View(cell_lines)
cl_vec = rownames(op_norm)
cl=cl_vec[1]
data=op_norm
subset = data %>% filter(cell_line==cl) #filter to just one cl at a time
library(tidyverse)
subset = data %>% filter(cell_line==cl) #filter to just one cl at a time
subset = as.data.frame(data) %>% filter(cell_line==cl) #filter to just one cl at a time
subset = as.data.frame(data) %>% dplyr::filter(cell_line==cl) #filter to just one cl at a time
sessionInfo()
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(oncoPredict)
library(tidyverse)
set.seed(323)
sig_drugs = c("Cisplatin", "Cytarabine", "5-Fluorouracil", "Gemcitabine", "Irinotecan",
"Luminespib", "Paclitaxel", "Topotecan", "Vinblastine", "Vorinostat")
cell_lines = readRDS(here("Data", "cleaned_cell_line_meta.rds"))
subtype_key = readRDS(here("Data", "subtype_key.rds"))
exprs_norm = readRDS(here("Data", "normalized_exprs.rds"))
acc_scores = readRDS(here("Results", paste0(length(sig_drugs),"sig_score_table.rds")))
#Read GDSC2 response data. rownames() are samples, colnames() are drugs.
trainingPtype = readRDS(file = here("Data", "Method Comparison Data","GDSC2_Res.rds"))
#keep only the same drugs we used in our chemogram
drug_prefixes = sub("_.*", "", colnames(trainingPtype))
keep_cols = drug_prefixes %in% sig_drugs
trainingPtype = trainingPtype[, keep_cols]
#convert from ln(IC50) to IC50
trainingPtype<-exp(trainingPtype)
#Read GDSC expression data for training.
trainingExprData=readRDS(file=here("Data", "Method Comparison Data", 'GDSC2_Expr_short.rds'))
#Load in the normalized GDSC expression data that we used in our method.
#This should be the same, but just in case its not exactly, we'll load in our version for consistency.
testExprData = t(exprs_norm)
colnames(testExprData) = testExprData[1,] #make the COSMIC id's the column names
testExprData = testExprData[-1,]
class(testExprData) = "numeric"
# Run the method
#Set parameters using the same ones as the vignette (except Rsq, since we're using the same training/testing data)
op_results = calcPhenotype(trainingExprData=trainingExprData,
trainingPtype=trainingPtype,
testExprData=testExprData,
batchCorrect="eb",
powerTransformPhenotype=TRUE,
removeLowVaryingGenes=0.2,
minNumSamples=10,
selection=1,
printOutput=TRUE,
pcr=FALSE,
removeLowVaringGenesFrom="homogenizeData",
report_pc=FALSE,
cc=FALSE,
percent=80,
rsq=TRUE,
folder=FALSE)
#the R-squareds for each drug are kinda all over, which is fine.
#it would be a problem if they were all 1, meaning that all
#the models were overfit bc the training and testing data were the same.
rm(testExprData, trainingExprData, trainingPtype, keep_cols, drug_prefixes)
op_norm = scale(op_results, center=TRUE)
cl=cl_vec[1]
subset = as.data.frame(data) %>% filter(cell_line==cl) #filter to just one cl at a time
View(data)
data = op_norm
data = as.data.frame(t(data))
View(data)
subset = data %>% filter(cell_line==cl) #filter to just one cl at a time
subset = data %>% select(cl) #filter to just one cl at a time
View(subset)
subset = data %>%
select(cl) %>% #filter to just one cl at a time
mutate(drug = sub("_.*", "", rownames(data)))
View(subset)
colnames(subset)
colnames(subset) = c("cl", "drug")
colnames(subset) = c("y", "drug")
subset = subset[order(subset$y, decreasing = FALSE),] #put drugs in order from most response to least response
View(subset)
subset$true_rank = (seq(1, 10)) #label the observed sensitivity rank
fit_results = readRDS(here("Results",
paste0(length(sigs), "sig_nlme_fitted_data.rds")))
fit_results = readRDS(here("Results",
paste0(length(sig_drugs), "sig_nlme_fitted_data.rds")))
View(fit_results)
unique(fit_results$drug_abbrev)
fit_results = readRDS(here("Results",
paste0(length(sig_drugs), "sig_nlme_fitted_data.rds"))) %>%
mutate(drug = case_when(drug=="cis" ~ "Cisplatin",
drug=="cyta" ~ "Cytarabine",
drug=="fu" ~ "5-Fluorouracil",
drug=="gem" ~ "Gemcitabine",
drug=="irino" ~ "Irinotecan",
drug=="lum" ~ "Luminespib",
drug=="pac" ~ "Paclitaxel",
drug=="topo" ~ "Topotecan",
drug=="vinb" ~ "Vinblastine",
drug=="vor" ~ "Vorinostat"))
fit_results = readRDS(here("Results",
paste0(length(sig_drugs), "sig_nlme_fitted_data.rds"))) %>%
mutate(drug = case_when(drug_abbrev=="cis" ~ "Cisplatin",
drug_abbrev=="cyta" ~ "Cytarabine",
drug_abbrev=="fu" ~ "5-Fluorouracil",
drug_abbrev=="gem" ~ "Gemcitabine",
drug_abbrev=="irino" ~ "Irinotecan",
drug_abbrev=="lum" ~ "Luminespib",
drug_abbrev=="pac" ~ "Paclitaxel",
drug_abbrev=="topo" ~ "Topotecan",
drug_abbrev=="vinb" ~ "Vinblastine",
drug_abbrev=="vor" ~ "Vorinostat"))
View(fit_results)
surv_subset = fit_results %>% filter(cell_line==cl)
View(surv_subset)
cl_vec = unique(fit_results$cell_line)
#keep only the cell lines that we have measured survival for
op_norm = op_norm[,cl_vec]
op_norm = op_results[,cl_vec]
op_norm = op_norm %>% select(all_of(cl_vec))
op_norm = as.data.frame(op_norm) %>% select(all_of(cl_vec))
cl_op = colnames(op_norm)
cl_op = rownames(op_norm)
inner_join(cl_vec, cl_op)
intersect(cl_vec, cl_op)
cl_vec = intersect(cl_vec, rownames(op_norm))
rm(cl_op)
op_norm = as.data.frame(op_norm) %>% select(all_of(cl_vec))
op_norm = op_norm %>% select(all_of(cl_vec))
op_norm = op_norm[,cl_vec]
op_norm = op_norm[cl_vec,]
data=op_norm
data = as.data.frame(t(data))
View(data)
surv_subset = fit_results %>% filter(cell_line==cl)
cl=cl_vec[1]
surv_subset = fit_results %>% filter(cell_line==cl)
subset = data %>%
select(cl) %>% #filter to just one cl at a time
mutate(drug = sub("_.*", "", rownames(data)))
View(surv_subset)
View(subset)
colnames(subset) = c("pred", "drug")
subset = full_join(subset, surv_subset, by="drug")
View(subset)
#rank the predictions
subset = subset[order(subset$pred, decreasing = FALSE),] #put drugs in order of increasing IC50 zscore (most sens to most res)
subset$pred_rank = (seq(1, 10)) #label the observed sensitivity rank
#rank the true response
subset = subset[order(subset$surv, decreasing = TRUE),] #put drugs in order from most response to least response
#rank the true response
subset = subset[order(subset$surv, decreasing = FALSE),] #put drugs in order from most response to least response
as.data.frame(t(subset$pred_rank))
score = match_df(acc_scores, as.data.frame(t(subset$pred_rank))) #find which score goes with the prediction ranking
score = plyr::match_df(acc_scores, as.data.frame(t(subset$pred_rank))) #find which score goes with the prediction ranking
score=as.numeric(score$score)
score
find_op_score = function(data, cl){
data = as.data.frame(t(data))
#subset data and combine predictions and actual drug response
surv_subset = fit_results %>% filter(cell_line==cl)
subset = data %>%
select(cl) %>% #filter to just one cl at a time
mutate(drug = sub("_.*", "", rownames(data)))
colnames(subset) = c("pred", "drug")
subset = full_join(subset, surv_subset, by="drug")
#rank the predictions
subset = subset[order(subset$pred, decreasing = FALSE),] #put drugs in order of increasing IC50 zscore (most sens to most res)
subset$pred_rank = (seq(1, 10)) #label the observed sensitivity rank
#rank the true response
subset = subset[order(subset$surv, decreasing = FALSE),] #put drugs in order from most response to least response
score = plyr::match_df(acc_scores, as.data.frame(t(subset$pred_rank))) #find which score goes with the prediction ranking
score=as.numeric(score$score)
return(score)
}
View(fit_results)
#df to store results in
op_acc = data.frame(cell_line=character(),
subtype=character(),
acc_score=numeric()
)
unique(fit_results%>%filter(cell_line==cl_vec[1])%>%select(subtype))
unique(fit_results%>%filter(cell_line==cl_vec[1])%>%select(subtype))[1]
unique(fit_results%>%filter(cell_line==cl_vec[1])%>%select(subtype))[[1]]
find_op_score = function(data, cl){
data = as.data.frame(t(data))
#subset data and combine predictions and actual drug response
surv_subset = fit_results %>% filter(cell_line==cl)
subset = data %>%
select(cl) %>% #filter to just one cl at a time
mutate(drug = sub("_.*", "", rownames(data)))
colnames(subset) = c("pred", "drug")
subset = full_join(subset, surv_subset, by="drug")
#rank the predictions
subset = subset[order(subset$pred, decreasing = FALSE),] #put drugs in order of increasing IC50 zscore (most sens to most res)
subset$pred_rank = (seq(1, 10)) #label the observed sensitivity rank
#rank the true response
subset = subset[order(subset$surv, decreasing = FALSE),] #put drugs in order from most response to least response
score = plyr::match_df(acc_scores, as.data.frame(t(subset$pred_rank))) #find which score goes with the prediction ranking
score=as.numeric(score$score)
return(score)
}
cl_vec[1]
for(c in 1:length(cl_vec)){
print(paste0((c/length(cl_vec))*100, "%"))
op_acc = rbind(op_acc, data.frame(
cell_line = cl_vec[c],
subtype = unique(fit_results%>%
filter(cell_line==cl_vec[c])%>%
select(subtype))[[1]],
acc_score = find_op_score(op_norm, cl_vec[c])
))
}
View(op_acc)
saveRDS(op_acc, here("Results", "oncopredict_rank_acc_scores.rds"))
ggplot(op_acc, aes(x=subtype, y=acc_score)) +
geom_point()
ggplot(op_acc, aes(x=subtype, y=acc_score)) +
geom_boxplot()
knitr::opts_chunk$set(echo = TRUE)
#save
# saveRDS(scored_ranks_full, here("Results", paste0(length(sigs),"sig_accuracy_scores_cleaned.rds")))
scored_ranks_full = readRDS(here("Results", paste0(length(sigs),"sig_accuracy_scores_cleaned.rds")))
#save
# saveRDS(scored_ranks_full, here("Results", paste0(length(sigs),"sig_accuracy_scores_cleaned.rds")))
scored_ranks_full = readRDS(here("Results", paste0(length(sig_drugs),"sig_accuracy_scores_cleaned.rds")))
View(scored_ranks_full)
ggplot(scored_ranks_full, aes(x = subtype, y=accuracy)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sigs), "-sig Chemogram"),
subtitle = paste0(nrow(scored_ranks_full)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
op_subtype = unique(op_acc$subtype)
op_subtype_scores = data.frame(subtype=op_subtype, accuracy=0, n = 0)
for (i in 1:length(op_subtype)){
#Subset data per subtype
subset = op_acc[which(op_acc$subtype == op_subtype[i]),]
#Store subtype name
op_subtype_scores$subtype[i] = op_subtype[i]
#calc and store % of cell line survivals correctly predicted
op_subtype_scores$accuracy[i] = round((sum(subset$accuracy)/nrow(subset)), digits=3)
#Indicate number of cell lines in subtype (n)
op_subtype_scores$n[i] = nrow(subset)
}
View(op_subtype_scores)
op_subtype_scores = data.frame(subtype=op_subtype, accuracy=0, n = 0)
for (i in 1:length(op_subtype)){
#Subset data per subtype
subset = op_acc[which(op_acc$subtype == op_subtype[i]),]
#Store subtype name
op_subtype_scores$subtype[i] = op_subtype[i]
#calc and store % of cell line survivals correctly predicted
op_subtype_scores$accuracy[i] = round((sum(subset$acc_score)/nrow(subset)), digits=3)
#Indicate number of cell lines in subtype (n)
op_subtype_scores$n[i] = nrow(subset)
}
View(op_subtype_scores)
#order the rows by highest to lowest correct
op_subtype_scores = op_subtype_scores[order(op_subtype_scores$accuracy),]
#To maintain this order when we plot later, factorize the column
op_subtype_scores$subtype <- factor(op_subtype_scores$subtype,
ordered = TRUE,
levels = op_subtype_scores$subtype)
cancer_order = (as.character(op_subtype_scores$subtype))[-c(which(as.character(op_subtype_scores$subtype)=="UNCLASSIFIED"))]
op_acc$subtype <- factor(op_acc$subtype,
ordered = TRUE,
levels = c(cancer_order))
op_acc = op_acc[order(op_acc$subtype),]
ggplot(op_acc, aes(x=subtype, y=acc_score)) +
geom_boxplot()
ggplot(op_acc, aes(x = subtype, y=acc_scores)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sigs), "-sig Chemogram"),
subtitle = paste0(nrow(op_acc)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
ggplot(op_acc, aes(x = subtype, y=acc_scores)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sig_drugs), "-sig Chemogram"),
subtitle = paste0(nrow(op_acc)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
ggplot(op_acc, aes(x = subtype, y=acc_scores)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL)
ggplot(op_acc, aes(x = subtype, y=acc_score)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sig_drugs), "-sig Chemogram"),
subtitle = paste0(nrow(op_acc)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
ggplot(op_acc %>% filter(subtype!="UNCLASSIFIED"),
aes(x = subtype, y=acc_score)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sig_drugs), "-sig Chemogram"),
subtitle = paste0(nrow(op_acc)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
cancer_order
op_acc = op_acc %>% filter(subtype != "UNCLASSIFIED")
op_acc$subtype <- factor(op_acc$subtype,
ordered = TRUE,
levels = c(cancer_order))
op_acc = op_acc[order(op_acc$subtype),]
op_subtype_scores = op_subtype_scores %>% filter(subtype != "UNCLASSIFIED")
ggplot(op_acc, aes(x = subtype, y=acc_score)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of ", length(sig_drugs), "-sig Chemogram"),
subtitle = paste0(nrow(op_acc)," Cell Lines"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
ggplot(op_acc, aes(x = subtype, y=acc_score)) + #select data to plot
geom_boxplot(width=0.4, fill="#9b2226", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6a040f") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of oncoPredict Ranking"),
subtitle = paste0(nrow(op_acc)," Cell Lines against 10 drugs"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
ggplot(op_acc, aes(x = subtype, y=acc_score)) + #select data to plot
geom_boxplot(width=0.4, fill="#c8b6ff", alpha = 0.6, fatten = NULL) + #boxplot, fatten=null is getting rid of the median line
ggbeeswarm::geom_quasirandom(method="smiley", width=0.2, alpha=0.4, size = 3, color="#6d597a") + #beeswarm
stat_summary(fun.y = mean, geom = "errorbar", aes(ymax = ..y.., ymin = ..y..), #add in a line to indicate the mean
width = 0.4, size = 2, linetype = "solid") +
geom_label(data=na.omit(op_subtype_scores), aes(x = subtype, y = 0, label = n), #add n
label.padding = unit(0.15, "lines"), label.size = 0.4, size = 8) +
scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) +
labs(title=paste0("Predictive Accuracy of oncoPredict Ranking"),
subtitle = paste0(nrow(op_acc)," Cell Lines against 10 drugs"),
y = "Predictive Accuracy", x = "Disease Site") +
theme_bw(base_size = 15) + #theme and sizing
theme(axis.text.y = element_text(size = 20),
axis.text.x = element_text(angle=30, size = 20, hjust=.9),
legend.position = "none",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
axis.text = element_text(size = 10))
ggsave(filename=here("Plots", "oncoPredict_accuracy_boxplots.png"),
width = 15, height = 9)
scored_ranks_full = readRDS(here("Results", paste0(length(sig_drugs),"sig_accuracy_scores_cleaned.rds")))
#create a new df with one row per subtype, and columns = subtype, proportion_correct
subtype = unique(scored_ranks_full$subtype)
subtype_scores = data.frame(subtype=subtype, accuracy=0, n = 0)
for (i in 1:length(subtype)){
#Subset data per subtype
subset = scored_ranks_full[which(scored_ranks_full$subtype == subtype[i]),]
#Store subtype name
subtype_scores$subtype[i] = subtype[i]
#calc and store % of cell line survivals correctly predicted
subtype_scores$accuracy[i] = round((sum(subset$accuracy)/nrow(subset)), digits=3)
#Indicate number of cell lines in subtype (n)
subtype_scores$n[i] = nrow(subset)
}
#order the rows by highest to lowest correct
subtype_scores = subtype_scores[order(subtype_scores$accuracy),]
#To maintain this order when we plot later, factorize the column
subtype_scores$subtype <- factor(subtype_scores$subtype,
ordered = TRUE,
levels = subtype_scores$subtype)
#remove unclassified cell lines
scored_ranks_full = scored_ranks_full %>% filter(subtype != "UNCLASSIFIED")
#Set order to = subtype_scores
cancer_order = (as.character(subtype_scores$subtype))[-c(which(as.character(subtype_scores$subtype)=="UNCLASSIFIED"))]
scored_ranks_full$subtype <- factor(scored_ranks_full$subtype,
ordered = TRUE,
levels = c(cancer_order))
scored_ranks_full = scored_ranks_full[order(scored_ranks_full$subtype),]
#remove unclassified from subtype score averages
subtype_scores$subtype <- factor(subtype_scores$subtype,
ordered = TRUE,
levels = c(cancer_order))
subtype_scores = subtype_scores[order(subtype_scores$subtype),]
rm(subset, cancer_order)
